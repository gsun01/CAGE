from __future__ import annotations
__all__ = ["E_mnp", "omega_mnp", "f_mnp", "Q_mnp_times_2Rs"]

import numpy as np
from scipy.special import jv, jvp

from include.custom_types import *
from include.bessel import BesselJZeros, BesselJpZeros

def _m_over_r_Jm(m: int, gamma: f64 | NDArray, r) -> NDArray:
    """Safe m/r with no 1/r singularity, using the Bessel identity."""
    if isinstance(gamma, np.ndarray):
        raise ValueError("Gamma must be a scalar when computing E_mnp to avoid broadcasting issues.")
    r = asarr_f64(r)
    return 0.5 * gamma * (jv(m - 1, gamma * r) + jv(m + 1, gamma * r))

# -------- core dispersion helpers --------

def _kz(p: int, L: f64 | NDArray) -> f64 | NDArray:
    if not (isinstance(p, int) and p >= 0):
        raise ValueError("p must be an integer >= 0")
    return p * np.pi / L

def _gamma(a: f64 | NDArray, family:Family, m: int, n: int) -> f64 | NDArray:
    if not (isinstance(m, int) and isinstance(n, int)):
        raise ValueError("m and n must be integers")
    if m < 0 or n <= 0:
        raise ValueError("m >= 0 and n > 0 are required")
    fam = family.upper()
    if fam == "TM":
        return BesselJZeros(m,n) / a
    elif fam == "TE":
        return BesselJpZeros(m,n) / a
    else:
        raise ValueError("family must be 'TE' or 'TM'")

# -------- public API --------

def E_mnp(
        a: f64 | NDArray, L: f64 | NDArray,
        R3, PHI3, Z3, 
        family: Family, m: int, n: int, p: int, sign: Sign='+',
    ) -> TripleV:
    """
    Return vectorized (Er, Ephi, Ez) arrays for the requested (family, m, n, p).
    R, PHI, Z are assumed to be generated by np.meshgrid with indexing="ij".
    """
    if isinstance(a, np.ndarray) or isinstance(L, np.ndarray):
        raise ValueError("a and L must be scalars when computing E_mnp to avoid broadcasting issues.")
    if sign not in {"+", "-"}:
        raise ValueError("sign must be '+' or '-'")

    fam = family.upper()
    _sign = "-" if (m == 0 and fam == "TM") else sign

    g = _gamma(a, family, m, n)
    kz = _kz(p, L)
    w = omega_mnp(a, L, family, m, n, p)

    kz_g, kz_g2 = kz/g, kz/(g*g)
    w_g2 = w / (g*g)

    smp = np.sin(m*PHI3)
    cmp = np.cos(m*PHI3)
    s_kz_z = np.sin(kz*Z3)
    c_kz_z = np.cos(kz*Z3)

    Jm = jv(m, g*R3)
    Jm_p = jvp(m, g*R3)
    m_over_r_Jm = _m_over_r_Jm(m, g, R3)

    if fam == "TM":
        Er_TM = -kz_g * (smp if _sign == "+" else cmp) * s_kz_z * Jm_p
        Ephi_TM = -kz_g2 * (cmp if _sign == "+" else -smp) * s_kz_z * m_over_r_Jm
        Ez_TM = (smp if _sign == "+" else cmp) * c_kz_z * Jm
        return asarr_c128(Er_TM), asarr_c128(Ephi_TM), asarr_c128(Ez_TM)
    else:   # TE
        Er_TE = 1j * w_g2 * (cmp if _sign == "+" else -smp) * s_kz_z * m_over_r_Jm
        Ephi_TE = -1j * w / g * (smp if _sign == "+" else cmp) * s_kz_z * Jm_p
        Ez_TE = np.zeros_like(Er_TE, dtype=np.complex128)
        return asarr_c128(Er_TE), asarr_c128(Ephi_TE), asarr_c128(Ez_TE)

def omega_mnp(a: f64 | NDArray, L: f64 | NDArray, 
              family: Family, m: int, n: int, p: int) -> f64 | NDArray:
    """
    Return the eigenfrequency Ï‰_mnp for the given (family, m, n, p).
    """
    g = _gamma(a, family, m, n)
    kz = _kz(p, L)
    return np.sqrt(g * g + kz * kz)

def f_mnp(a: f64 | NDArray, L: f64 | NDArray, 
              family: Family, m: int, n: int, p: int) -> f64 | NDArray:
    """
    Return the eigenfrequency f_mnp in GHz for the given (family, m, n, p).
    """
    w_mnp = omega_mnp(a, L, family, m, n, p)
    return w_mnp/(2*np.pi)*0.3

def Q_mnp_times_2Rs(a: f64 | NDArray, L: f64 | NDArray,
                    family: Family, m: int, n: int, p: int) -> f64 | NDArray:
    """
    Return the quality factor Q_mnp multiplied by 2R_s for the given (family, m, n, p).
    Assumes sqrt{mu/epsilon} = 1.
    """
    g = _gamma(a, family, m, n)
    kz = _kz(p, L)
    g2, kz2 = g*g, kz*kz
    m_over_a_sq = m*m / (a * a)
    if family == "TM":
        return np.sqrt(g2 + kz2) * a * L / (a + L)
    elif family == "TE":
        return a * (  np.power(g2+kz2,1.5)*(g2-m_over_a_sq) / ((m_over_a_sq)*kz2 + g2*g2 + 2*a/L*kz2*(g2-m_over_a_sq))  )


if __name__ == "__main__":
    # Example usage
    a, L = 0.0206, 0.2032
    